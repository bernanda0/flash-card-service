// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: card.query.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createFlashcard = `-- name: CreateFlashcard :one
INSERT INTO flashcard (
  deck_id, question, answer, next_review_date,
  interval, repetitions, easiness_factor
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING flashcard_id, deck_id, question, answer, next_review_date, interval, repetitions, easiness_factor, created_at, updated_at, is_archived
`

type CreateFlashcardParams struct {
	DeckID         sql.NullInt32   `json:"deck_id"`
	Question       string          `json:"question"`
	Answer         string          `json:"answer"`
	NextReviewDate sql.NullTime    `json:"next_review_date"`
	Interval       sql.NullInt32   `json:"interval"`
	Repetitions    sql.NullInt32   `json:"repetitions"`
	EasinessFactor sql.NullFloat64 `json:"easiness_factor"`
}

func (q *Queries) CreateFlashcard(ctx context.Context, arg CreateFlashcardParams) (Flashcard, error) {
	row := q.db.QueryRowContext(ctx, createFlashcard,
		arg.DeckID,
		arg.Question,
		arg.Answer,
		arg.NextReviewDate,
		arg.Interval,
		arg.Repetitions,
		arg.EasinessFactor,
	)
	var i Flashcard
	err := row.Scan(
		&i.FlashcardID,
		&i.DeckID,
		&i.Question,
		&i.Answer,
		&i.NextReviewDate,
		&i.Interval,
		&i.Repetitions,
		&i.EasinessFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsArchived,
	)
	return i, err
}

const deleteFlashcard = `-- name: DeleteFlashcard :exec
DELETE FROM flashcard
WHERE flashcard_id = $1
`

func (q *Queries) DeleteFlashcard(ctx context.Context, flashcardID int32) error {
	_, err := q.db.ExecContext(ctx, deleteFlashcard, flashcardID)
	return err
}

const getFlashcard = `-- name: GetFlashcard :one
SELECT flashcard_id, deck_id, question, answer, next_review_date, interval, repetitions, easiness_factor, created_at, updated_at, is_archived FROM flashcard
WHERE flashcard_id = $1 LIMIT 1
`

func (q *Queries) GetFlashcard(ctx context.Context, flashcardID int32) (Flashcard, error) {
	row := q.db.QueryRowContext(ctx, getFlashcard, flashcardID)
	var i Flashcard
	err := row.Scan(
		&i.FlashcardID,
		&i.DeckID,
		&i.Question,
		&i.Answer,
		&i.NextReviewDate,
		&i.Interval,
		&i.Repetitions,
		&i.EasinessFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsArchived,
	)
	return i, err
}

const listFlashcardsByDeck = `-- name: ListFlashcardsByDeck :many
SELECT flashcard_id, deck_id, question, answer, next_review_date, interval, repetitions, easiness_factor, created_at, updated_at, is_archived FROM flashcard
WHERE deck_id = $1
ORDER BY created_at
`

func (q *Queries) ListFlashcardsByDeck(ctx context.Context, deckID sql.NullInt32) ([]Flashcard, error) {
	rows, err := q.db.QueryContext(ctx, listFlashcardsByDeck, deckID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Flashcard
	for rows.Next() {
		var i Flashcard
		if err := rows.Scan(
			&i.FlashcardID,
			&i.DeckID,
			&i.Question,
			&i.Answer,
			&i.NextReviewDate,
			&i.Interval,
			&i.Repetitions,
			&i.EasinessFactor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsArchived,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlashcard = `-- name: UpdateFlashcard :exec
UPDATE flashcard
SET question = $1, answer = $2, next_review_date = $3,
    interval = $4, repetitions = $5, easiness_factor = $6,
    updated_at = NOW()
WHERE flashcard_id = $7
`

type UpdateFlashcardParams struct {
	Question       string          `json:"question"`
	Answer         string          `json:"answer"`
	NextReviewDate sql.NullTime    `json:"next_review_date"`
	Interval       sql.NullInt32   `json:"interval"`
	Repetitions    sql.NullInt32   `json:"repetitions"`
	EasinessFactor sql.NullFloat64 `json:"easiness_factor"`
	FlashcardID    int32           `json:"flashcard_id"`
}

func (q *Queries) UpdateFlashcard(ctx context.Context, arg UpdateFlashcardParams) error {
	_, err := q.db.ExecContext(ctx, updateFlashcard,
		arg.Question,
		arg.Answer,
		arg.NextReviewDate,
		arg.Interval,
		arg.Repetitions,
		arg.EasinessFactor,
		arg.FlashcardID,
	)
	return err
}
